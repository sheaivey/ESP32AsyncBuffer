const fs = require("fs");
const path = require("path");
const consoleOut = require("./src/utils/ConsoleOut.js");
const packContents = require("./src/utils/packContents.js");
const {parseStructs, getAllTypes} = require("./src/utils/parseStructs.js");
const watchForChanges = require("./src/utils/watchForChanges.js");
const {roundTo, readDirR, createFile} = require("./src/utils/helpers.js");

const scriptDir = path.dirname(process.argv[1]);
const workingDir = process.cwd() || '.';

const isBuildingLibrary = workingDir == scriptDir;

const defaultSettings = {
  modelsDir: '/models',
  htmlDir: '/html',
  outputFile: '/dist/_GENERATED_SOURCE.h',
  useChecksum: true,
  minify: true,
  inline: false,
  gzip: true,
  outputSources: false,
};
let settings = {...defaultSettings};
const SETTINGS_FILE = `${workingDir}/GenerateSources.json`;
const CLIENT_API_FILE = scriptDir + "/src/AsyncBufferAPI.js";

let MODELS_DIR = `${workingDir}${settings.modelsDir}`;
let HTML_DIR = `${workingDir}${settings.htmlDir}`;
let OUTPUT_FILE = `${workingDir}${settings.outputFile}`;

const loadSettings = () => {
  settings = {...defaultSettings}; // reset defaults
  try {
    if(fs.existsSync(SETTINGS_FILE)) {
      settings = {...settings, ...JSON.parse(fs.readFileSync(SETTINGS_FILE))};
    }
    else {
      createFile(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    }
    MODELS_DIR = `${workingDir}${settings.modelsDir}`;
    HTML_DIR = `${workingDir}${settings.htmlDir}`;
    OUTPUT_FILE = `${workingDir}${settings.outputFile}`;
    if (isBuildingLibrary) {
      OUTPUT_FILE = `./dist/_GENERATED_SOURCE.h`;
    }
  }
  catch {
    consoleOut.print("WARNING: could not create local settings file \n  './GenerateSourcesSettings.json' using default settings.");
  }
};
loadSettings();


// Main script execution
async function main() {
  consoleOut.log(`\nProcessing all structs in '${MODELS_DIR.replace(workingDir,".")}'...\n`);
  let packedSize = 0;
  let unpackedSize = 0;
  // scan ./models structs
  let structDefinitions = readDirR(MODELS_DIR)
    .filter((file) => file.indexOf("/build") == -1 && !path.basename(file).startsWith("_") && (file.endsWith(".h") || file.endsWith(".cpp")))
    .map((file) => fs.readFileSync(file, "utf-8"))
    .join("\n");
  let structs = parseStructs(structDefinitions);
  const allTypes = getAllTypes();

  consoleOut.log(`Done!\n\nPackaging all static files in '${HTML_DIR.replace(workingDir,".")}'...\n`);
  // Append the client encoding/decoding scripts.
  let AsyncBufferAPIContent = "";
  AsyncBufferAPIContent += fs.readFileSync(CLIENT_API_FILE, "utf-8").replace(' useChecksum: false,', ` useChecksum: ${settings.useChecksum},`);
  const models = JSON.stringify(structs);
  let stringContents = contents = `"use strict";\n\nconst _structs = ${models};\n\n${AsyncBufferAPIContent}\n`;
  let outputContents = `// ** FILE GENERATED BY - ESP32AsyncBuffer **
// node Arduino/libraries/ESP32AsyncBuffer/GenerateSources.js \n
// ${path.basename(OUTPUT_FILE)}
#ifndef _ASYNC_BUFFER_GENERATED_SOURCE_H
#define _ASYNC_BUFFER_GENERATED_SOURCE_H
#define _ASYNC_BUFFER_GENERATED_SOURCE_INCLUDE "${OUTPUT_FILE}"
#define _ASYNC_BUFFER_USE_CHECKSUM ${settings.useChecksum}

`;

  let customTypes = false;
  outputContents += `// All known types
enum AsyncBufferTypes {
  UNKNOWN_TYPE = -1,

  // Primitive Types
${allTypes.map((t) => {
  let extra = '';
  if (t.primitive == false && customTypes == false) {
    customTypes = true;
    extra = '\n  // Custom Types\n';
  }
  return `${extra}  ${t.name.toUpperCase().replace(/([^A-Za-z0-9]+)/ig, "_")} = ${t.id}`;
}).join(",\n")},

  // END
  _EOF = ${allTypes.length}
};\n`;

  outputContents += `// Types Lookup array
  const char* const AsyncBufferTypeNames[] = {
  ${getAllTypes().map((t) => `"${t.name}"`).join(', ')}
};\n\n
// AsyncBufferTypes and AsyncBufferTypeNames must be defiend 
// before including AsyncBuffer.h
#include "AsyncBuffer.h"\n`;

  const result = await packContents("/js/models.js", stringContents, { ...settings, rootDir: HTML_DIR });
  const processedFiles = [result];

  // scan ./html dir and attempt to create entries for static files.
  const files = await readDirR(HTML_DIR);
  for (const file of files) {
    const fileContents = fs.readFileSync(file);
    const processedFile = await packContents(file, fileContents, { ...settings, rootDir: HTML_DIR });
    processedFiles.push(processedFile);
  }
  let bootstrapRequests = `AsyncBufferStaticFile staticFiles[] = {\n`;
  processedFiles.forEach(f => {
    body = f[0];
    info = f[1];
    unpackedSize += info.inSize;
    packedSize += info.outSize;
    outputContents += body;
    bootstrapRequests += `  ${info.staticFileName},\n`;
    if(settings.outputSources) {
      createFile(path.dirname(OUTPUT_FILE)+info.path.replace(HTML_DIR,''), info.contents);
    }
  });
  bootstrapRequests += `};\nsize_t staticFilesLength = ${processedFiles.length};\n`;
  outputContents += bootstrapRequests;
  outputContents += `#endif // ${path.basename(OUTPUT_FILE)}`;

  console.log("\nDone!");
  let hasErrors = false;
  let hasWarnings = false;
  consoleOut.messages.forEach(([m]) => {
    if(m.indexOf("ERROR") !== -1) {
      hasErrors = true;
    }
    if(m.indexOf("WARNING") !== -1) {
      hasWarnings = true;
    }
  });
  if(!hasErrors) {
    // success
    createFile(OUTPUT_FILE, outputContents);
    consoleOut.queue(`\n${!hasWarnings ? 'SUCCESS' : 'WARNING'}: All files processed into '${OUTPUT_FILE.replace(workingDir,".")}'`);
    consoleOut.queue(`         Total ${roundTo(packedSize / 1024)}KB (was ${roundTo(unpackedSize / 1024)}KB saved ${roundTo((unpackedSize - packedSize) / 1024)}KB or ${roundTo((1 - (packedSize / unpackedSize)) * 100)}% reduction)`);
  }
  else {
    consoleOut.queue(`\nERROR: Could not generate '${OUTPUT_FILE.replace(workingDir,".")}' see above for errors.`);
  }
  consoleOut.flush();
  consoleOut.log(`\n\nWatching for changes in '${MODELS_DIR.replace(workingDir,'.')}', '${HTML_DIR.replace(workingDir,'.')}'...\n`);
}


main();

if(!isBuildingLibrary) {
  watchForChanges(workingDir+"/", (events) => {
    eventsFiltered = events.filter(([eventType, filename]) => {
      return filename && (
        filename.indexOf(MODELS_DIR) !== -1 // watch models
        || filename.indexOf(HTML_DIR) !== -1 // watch html
        || filename.indexOf(SETTINGS_FILE) !== -1 // watch settings 
      )
    });
    if(eventsFiltered.length) {
      loadSettings();
      consoleOut.clear();
      main();
    }
  });
}