const fs = require("fs");
const path = require("path");
const consoleOut = require("./src/utils/ConsoleOut.js");
const packContents = require("./src/utils/packContents.js");
const parseStructs = require("./src/utils/parseStructs.js");
const watchForChanges = require("./src/utils/watchForChanges.js");


const scriptDir = path.dirname(process.argv[1]);
const workingDir = process.cwd() || '.';

const OUTPUT_MINIFY = true;
const OUTPUT_GZIPPED = true;
const CLIENT_API_FILE = scriptDir + "/src/AsyncWebServerBufferAPI.js";

const MODELS_DIR = process.argv[2] ? `${workingDir}/${process.argv[2]}` : `${workingDir}/models`;
const HTML_DIR = process.argv[2] ? `${workingDir}/${process.argv[2]}` : `${workingDir}/html`;
const OUTPUT_FILE = process.argv[3] ? `${workingDir}/${process.argv[3]}` : `${workingDir}/dist/_STATIC_HTML_FILES.h`;

function readDirR(dir) {
  const files = fs.statSync(dir).isDirectory()
      ? Array.prototype.concat(...fs.readdirSync(dir).map(f => {
        return readDirR(path.join(dir, f));
      }))
      : dir;
  return files;
}

function createFile(filePath, content = '') {
  try {
    // Create directory path if it doesn't exist
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    // Create file
    fs.writeFileSync(filePath, content);
    // console.log(`File created successfully at ${filePath}`);
  } catch (error) {
    consoleOut.queue(`ERROR: creating file: ${error}`);
  }
}



// Main script execution
async function main() {
  console.log(`\nProcessing all structs in "${MODELS_DIR.replace(workingDir,".")}"...\n`);

  // scan for models models
  let structDefinitions = readDirR(MODELS_DIR)
    .filter((file) => file.indexOf("/build") == -1 && !path.basename(file).startsWith("_") && (file.endsWith(".h") || file.endsWith(".cpp")))
    .map((file) => fs.readFileSync(file, "utf-8"))
    .join("\n");
  let structs = parseStructs(structDefinitions);
  // Append the client encoding/decoding scripts.
  let extra = "";
  extra += fs.readFileSync(CLIENT_API_FILE, "utf-8");
  const models = JSON.stringify(structs);
  let stringContents = contents = `"use strict";\n\nconst _structs = ${models};\n\n${extra}\n`;
  let outputContents = "// ** FILE GENERATED BY - AsyncWebServerBuffer **\n";
  outputContents += "// node ~/Documents/Arduino/libraries/AsyncWebServerBuffer/GenerateSources.js [<models directory>=./models/] [<html directory>=./html/] [<output file>=./dist/_STATIC_HTML_FILES.h]\n\n";
  const result = await packContents("/js/models.js", stringContents, {gzip: OUTPUT_GZIPPED, minify: OUTPUT_MINIFY});
  const processedFiles = [result];

  // scan ./html dir and attempt to create entries for static files.
  const files = await readDirR(HTML_DIR);
  for (const file of files) {
    const fileContents = fs.readFileSync(file);
    const processedFile = await packContents(file.replace(HTML_DIR, ""), fileContents, { gzip: OUTPUT_GZIPPED, minify: OUTPUT_MINIFY });

    if (processedFile[1].path === "/index.html") {
      processedFile[1].path = '/'; // root request
    }

    processedFiles.push(processedFile);
  }

  let bootstrapRequests = `#include "AsyncWebServerBuffer.h"\nvoid initializeStaticFilesRequests(AsyncWebServerBuffer *server) {\n`;
  processedFiles.forEach(f => {
    body = f[0];
    info = f[1];
    outputContents += body;
    bootstrapRequests += `  server->onStatic("${info.path}", ${info.contentTypeName}, ${info.bodyName}, sizeof(${info.bodyName}), ${info.etagName}, ${info.gzipName});\n`
  });
  bootstrapRequests += "}\n";
  outputContents += bootstrapRequests;

  createFile(OUTPUT_FILE, outputContents);
  
  if(consoleOut.messages.filter(m => (m.indexOf("ERROR") !== -1 || m.indexOf("WARNING") !== -1)).length === 0) {
    consoleOut.queue(`\nSUCCESS: All files processed into "${OUTPUT_FILE.replace(workingDir,".")}"`);
  }
  else {
    consoleOut.queue(`\nWARNING: All files processed into "${OUTPUT_FILE.replace(workingDir,".")}" with warnings!`);
  }

  consoleOut.flush();
  ;
  console.log(`Watching for changes in '${MODELS_DIR.replace(workingDir,'.')}', '${HTML_DIR.replace(workingDir,'.')}'...\n`);
}


main();


watchForChanges(workingDir+"/", (events) => {
  eventsFiltered = events.filter(([eventType, filename]) => filename && (filename.indexOf(MODELS_DIR) !== -1 || filename.indexOf(HTML_DIR) !== -1 ));
  if(eventsFiltered.length) {
    console.log("\x1Bc"); // clear the console
    main();
  }
});


