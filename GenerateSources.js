const fs = require("fs");
const path = require("path");
const consoleOut = require("./src/utils/ConsoleOut.js");
const packContents = require("./src/utils/packContents.js");
const parseStructs = require("./src/utils/parseStructs.js");
const watchForChanges = require("./src/utils/watchForChanges.js");
const {roundTo, readDirR, createFile} = require("./src/utils/helpers.js");


const scriptDir = path.dirname(process.argv[1]);
const workingDir = process.cwd() || '.';


const OUTPUT_INLINE = false;
const OUTPUT_MINIFY = true;
const OUTPUT_GZIPPED = true;
const CLIENT_API_FILE = scriptDir + "/src/AsyncBufferAPI.js";

const MODELS_DIR = process.argv[2] ? `${workingDir}/${process.argv[2]}` : `${workingDir}/models`;
const HTML_DIR = process.argv[2] ? `${workingDir}/${process.argv[2]}` : `${workingDir}/html`;
const OUTPUT_FILE = process.argv[3] ? `${workingDir}/${process.argv[3]}` : `${workingDir}/dist/_STATIC_HTML_FILES.h`;

// Main script execution
async function main() {
  console.log(`\nProcessing all structs in "${MODELS_DIR.replace(workingDir,".")}"...\n`);
  let packedSize = 0;
  let unpackedSize = 0;
  // scan ./models structs
  let structDefinitions = readDirR(MODELS_DIR)
    .filter((file) => file.indexOf("/build") == -1 && !path.basename(file).startsWith("_") && (file.endsWith(".h") || file.endsWith(".cpp")))
    .map((file) => fs.readFileSync(file, "utf-8"))
    .join("\n");
  let structs = parseStructs(structDefinitions);
  // Append the client encoding/decoding scripts.
  let extra = "";
  extra += fs.readFileSync(CLIENT_API_FILE, "utf-8");
  const models = JSON.stringify(structs);
  let stringContents = contents = `"use strict";\n\nconst _structs = ${models};\n\n${extra}\n`;
  let outputContents = "// ** FILE GENERATED BY - ESP32AsyncBuffer **\n";
  outputContents += "// node Arduino/libraries/ESP32AsyncBuffer/GenerateSources.js \n\n";
  const result = await packContents("/js/models.js", stringContents, {inline: OUTPUT_INLINE, gzip: OUTPUT_GZIPPED, minify: OUTPUT_MINIFY});
  const processedFiles = [result];

  // scan ./html dir and attempt to create entries for static files.
  const files = await readDirR(HTML_DIR);
  for (const file of files) {
    const fileContents = fs.readFileSync(file);
    const processedFile = await packContents(file, fileContents, {inline: OUTPUT_INLINE, gzip: OUTPUT_GZIPPED, minify: OUTPUT_MINIFY});

    if (processedFile[1].path.replace(HTML_DIR,"") === "/index.html") {
      processedFile[1].path = '/'; // root request
    }

    processedFiles.push(processedFile);
  }

  let bootstrapRequests = `#include "AsyncWebServerBuffer.h"\nvoid initializeStaticFilesRequests(AsyncWebServerBuffer *server) {\n`;
  processedFiles.forEach(f => {
    body = f[0];
    info = f[1];
    unpackedSize += info.inSize;
    packedSize += info.outSize;
    outputContents += body;
    bootstrapRequests += `  server->onStatic("${info.path.replace(HTML_DIR,"")}", ${info.contentTypeName}, ${info.bodyName}, sizeof(${info.bodyName}), ${info.etagName}, ${info.gzipName});\n`
  });
  bootstrapRequests += "}\n";
  outputContents += bootstrapRequests;

  createFile(OUTPUT_FILE, outputContents);

  
  if(consoleOut.messages.filter(m => (m.indexOf("ERROR") !== -1 || m.indexOf("WARNING") !== -1)).length === 0) {
    consoleOut.queue(`\nSUCCESS: All files processed into "${OUTPUT_FILE.replace(workingDir,".")}"`);
  }
  else {
    consoleOut.queue(`\nWARNING: All files processed into "${OUTPUT_FILE.replace(workingDir,".")}" with warnings!`);
  }

  consoleOut.queue(`\INFO: Total ${roundTo(packedSize/1024)}kb (was ${roundTo(unpackedSize/1024)}kb saved ${roundTo((unpackedSize - packedSize)/1024)}kb or ${roundTo((1 - (packedSize/unpackedSize)) * 100)}% reduction)`);

  consoleOut.flush();

  console.log(`\n\nWatching for changes in '${MODELS_DIR.replace(workingDir,'.')}', '${HTML_DIR.replace(workingDir,'.')}'...\n`);
}


main();


watchForChanges(workingDir+"/", (events) => {
  eventsFiltered = events.filter(([eventType, filename]) => filename && (filename.indexOf(MODELS_DIR) !== -1 || filename.indexOf(HTML_DIR) !== -1 ));
  if(eventsFiltered.length) {
    consoleOut.clear();
    main();
  }
});


